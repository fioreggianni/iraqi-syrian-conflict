<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link type="text/css" rel="stylesheet" href="css/style.css">
    <link type="text/css" rel="stylesheet" href="css/d3/d3.slider.css">
    <link type="text/css" rel="stylesheet" href="css/d3/d3-tip.css">
    <link type="text/css" rel="stylesheet" href="css/conflicts.css">
    <script src="js/d3/d3.v3.min.js"></script>
    <script type="text/javascript" src="js/d3/d3.layout.js"></script>
    <script type="text/javascript" src="js/d3/d3.slider.js"></script>
    <script type="text/javascript" src="js/d3/d3-tip.js"></script>
    <script type="text/javascript" src="js/utils.js"></script>
  </head>
<body>
<script>
var w = window.innerWidth, h = window.innerHeight,
    x = d3.scale.linear().range([0, w]), y = d3.scale.linear().range([0, h]),
    root, node;
var mapw = w, maph = w * 0.647
	, data = {}
	, conflicts = []
	, conflictsByPlace = {}
	, conflictsTotals = {}
	, cmap = null
	, cbp = null
	, sMonth = 5
	, sYear = 2015

cmap = d3.layout.conflictmap()
    .size([w, h])
    .value(function(conflict) { return conflict.strikes; });
   
cbp = d3.nest()
    .key(function(conflict) { 
    	return conflict.place.name; 
    })
    .rollup(function(conflictsGroup){
      return {
        totalAttacks: conflictsGroup.filter(function(c){ return c.date.year == sYear && c.date.month+1 == sMonth}).length,
        totalStrikes: d3.sum(conflictsGroup, function(c){ 
        	if (c.date.year == sYear && c.date.month+1 == sMonth ) return c.strikes;
        	return 0;
        }),
        place: conflictsGroup[0].place
      }
    });

ct = d3.nest()
    .key(function(placeConflicts) { return "totals"; })
    .rollup(function(placeConflictsGroup) {
      return {
        totalStrikes: d3.sum(placeConflictsGroup, function(pc){ return pc.values.totalStrikes}),
        totalAttacks: d3.sum(placeConflictsGroup, function(pc){ return pc.values.totalAttacks}),
        maxStrikes: d3.max(placeConflictsGroup, function(pc){ return pc.values.totalStrikes}),
        maxAttacks: d3.max(placeConflictsGroup, function(pc){ return pc.values.totalAttacks})
      }
    })

var svg = d3
	.select("body")
	.append("div")
	    .attr("class", "main")
		.append("svg:svg")
		    .attr("width", w)
		    .attr("height", h)
		  	.append("svg:g");
svg.append("svg:image")
   .attr('class', 'mainmap')
   .attr('x',0)
   .attr('y',0)
   .attr('width', mapw)
   .attr('height', maph)
   .attr("xlink:href","bgmap.svg")


var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(placeConflicts) {
  	var values = placeConflicts.values;
    return "<span class='near-city'>near</span><br><strong>{0}</strong><br><span class='country-name'>{1}</span><br><hr><strong>Strikes:</strong> <span style='color:red'>{2}</span>"
	    .format(placeConflicts.key, values.place.country, values.totalStrikes);
  })


function updateConflicts(nodes){
	conflicts = nodes;
  	conflictsByPlace = cbp.entries(nodes);
    conflictsTotals = ct.map(conflictsByPlace);
}

d3.json("strikes.json", function(jsondata) {
  data = jsondata
  cmap = cmap.nodes(jsondata, mapw, maph);  
  updateConflicts(cmap.nodes());
  
var targetSet = 
	svg.selectAll("g")
	// foreach place with conflicts
	.data(conflictsByPlace)
	.enter()
	// draw a new <svg><g></g></svg> element
	.append("svg:g")
	// center it to place coords
	.attr("transform", function(placeConflicts) { 
		var coords = placeConflicts.values.place.coordinates;
		return "translate({0},{1})".format(coords.x, coords.y);
	})
	.on("mouseover", tip.show)
	.on("mousemove", tip.show)
	.on("mouseout", tip.hide);


// draw a background circle, too, to bind the tip to it
targetSet.append('svg:circle')
	   .attr('cx', 23)
	   .attr('cy',23)
	   .attr('r',20)
	   .attr('class', "targetBg")
	   .attr('opacity', 0.01)
	   .call(tip)

// now draw each target into his own svg element
var target = targetSet
	.append('svg:path')
	// resize each target path
    .attr('transform','scale(0.5)')
    .attr('class', 'target')
    .attr('d', _targetPath)
    // fill is depending on totalStrikes
   	.attr('fill', function(placeConflict) {
      var percentage = placeConflict.values.totalStrikes / conflictsTotals.totals.maxStrikes;
      if (percentage <= 0 || percentage >= 1) console.log("percentage: "+percentage);
      var startr = 254, startg = 198, startb = 108,
          endr = 168, endg = 0, endb = 4;
      var diffr = endr - startr,
          diffg = endg - startg,
          diffb = endb - startb;

      var r = Math.floor(diffr * percentage + startr),
        g = Math.floor(diffg * percentage + startg),
        b = Math.floor(diffb * percentage + startb);
      var color = "rgb("+r+","+g+","+b+")";
      return color;
   })
	// opacity is depending on totalStrikes
   .attr('opacity', function(placeConflict) {
      var minimumOpacity = 0.3;
      return minimumOpacity + placeConflict.values.totalStrikes*(1-minimumOpacity)/ conflictsTotals.totals.maxStrikes;
   });

var ts = d3.timeslider(svg)
  .width(w)
  .height(100)
  .timeRange([new Date("2015-01-01"), new Date("2016-08-31")])
  .startDate(new Date("2016-01-01"))
  // whenever the timeslider changes its value
  .onBrush(function(date){
  		sMonth = date.getMonth()+1
  		sYear = date.getFullYear()
  		//console.log(JSON.stringify(conflictsByPlace))
  		var filtered = conflictsByPlace.filter(function(placeConflict){
			return placeConflict.values.totalStrikes == 0;
		})
	  	d3.selectAll(".target")
			.data(filtered)
			.exit()
			.remove()
  });

// draw the timeslider into a new <g> element
svg.append('g')
	.attr('id','timeslider')
	.call(ts.draw);

d3.selectAll(".target")
   .transition()
   .duration(2000)
   .delay(0,1)
   .attr("transform", "scale(0.7) translate(-10,-10)")

});

function size(conflict) {
  return conflict.strikes;
}

function count(conflict) {
  return 1;
}
    
</script>
</body>
</html>